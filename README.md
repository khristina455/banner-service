# banner-service
Решение тестового задания - https://github.com/avito-tech/backend-trainee-assignment-2024
Выполнены все задания, кроме удаление по фиче или тэгу
# Запуск
  ## Необходимые зависимости: 
  ```
  docker
  docker-compose
  ```
  
  ## Запуск тестов:  
  
  `make test`
  
  ## Запуск самого сервиса: 
  
  `make run`

# Примеры запросов

  Примеры запросов находятся в `/postman/Banner Service.postman_collection.json`

# Нагрузочное тестирование

  Находится в `/report/index.html`. Нагрузочное тестирование проводилось 10 минут с 1000+ rps. Было обработано 612600 запросов, среди которых 600 запросов на создание баннеров, 102 100 на обновление поля content у баннеров и 510 500 запросов на получение содержимого баннеров для пользователей. Из всех запросов только 20 превысили 50 мс.

# Реширование возникших проблем

## Оптимизация времени получения баннеров
  1. Так как в условии говорилось о возможной неактуальности информации для пользователя в течении 5 минут, то можно использовать кэширование для данного вида запросов с ttl 5 минут. Для кэширования был выбран Redis, он быстрый и удобный. Будем хранить в нем содержимое баннеров в виде байтового массива, а ключом будет тэг + фича.
  2. Во избежании join денормализуем базу данных(будем хранить информаци о связях баннеров, фичей и тэгов в одном месте).
     
     ![image](https://github.com/khristina455/banner-service/assets/91967143/dae9be3a-6d36-4f20-8d88-5c5924696bc6)

  3. Также предположим, что админов немного и запись в базу происходит реже чтения, поэтому создадим индексы. Они также помогут при увеличении количества тэгов и фичей.
## Адаптация система для увеличения количества фичей и тэгов
  1. Создание индексов.
  2. Ограничение max memory для Redis и выбор политики очистки лишних данных allkeys-lru, так как в условии разрешалось дольше отдавать редко используемые баннеры.
## Авторизация
  Для авторизации используется jwt, лежащий в куке в поле AccessToken, в котором хранится флаг админства, user id и tag id. При вызове соотвествующих ручек проверяется админство и tag id для обычных пользователей.
## Версионирование баннеров
  В условиях не сказано как создаются версии баннеров, поэтому будем считать, что версии баннеров создаются при каждом изменении поля content, старые версии хранятся в таблице banner_version(не больше трех на один баннер). Для получения версий баннеров используется ручка `GET: /api/banner/{id}`. Для отката к предыдущей версии используется ручка `PUT: /api/banner/{id}`, подразумевается, что откат используется при ошибках в более старших версиях, поэтому они удаляются. Новое api лежит в `/openapi.yaml`.
